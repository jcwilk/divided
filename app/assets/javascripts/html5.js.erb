//= require phaser
//= require move_matrix

$(function() {
  var sliderContainer = {};
  var player_uuid = window._divided_player_uuid;
  var first_move = window._divided_first_move;

  var sliderChange =
  $('.slider').slider({min: 1, max: 5000,
    slide: function(event,ui){
      var varname = $(ui.handle.parentElement).data('variable');
      $('td#'+varname+'-display').html(ui.value);
      sliderContainer[varname] = ui.value;
    },
    create: function(event,ui){
      var target = $(event.target);
      var val = target.data('default');
      target.slider('option',{min: val/2, max: val*2});
      target.slider('value',target.data('default'));
      sliderContainer[target.data('variable')] = target.data('default');
    }
  });

  var background, walls, floor, cursors;
  var xPosToX = function(xPos) {
    return xPos*40+20+200;
  }
  var yPosToY = function(yPos) {
    return xPosToX(yPos)-100;
  }
  var xToXPos = function(x) {
    return Math.round((x-20-200)/40);
  }
  var yToYPos = function(y) {
    return xToXPos(y+100);
  }
  var turnCount = 0;
  var playerPosMap = {};

  var faye = new Faye.Client('/faye');

  var player;
  console.log(first_move);
  var souls, popups, waitingIcons, glows;
  var isPointerDown = false;

  var FACE_WIDTH = 30;
  var FACE_HEIGHT = 32;
  var TILE_SIZE = 40;

  var mm = window.MoveMatrix();

  var newWaitingDoom = function(xPos,yPos,uuid){
    var doom = game.add.sprite(
      xPosToX(xPos)-FACE_WIDTH/2, yPosToY(yPos)-FACE_HEIGHT/2, 'doomfaces'
    );

    doom.animations.add('waiting',[4,4,4,4,4,4,3,5],2,true);
    doom.animations.play('waiting');

    souls.add(doom);
    doom.currentPos = [xPos,yPos];
    doom.uuid = uuid;

    return doom;
  }

  var game = new Phaser.Game(800, 600, Phaser.AUTO, 'divided-viewport', {
    preload: function() {
      <%= %w(starfield.jpg slate_flooring_40x40.png 2x2brown40x40.png).map{|f| name=f.split('.').first; "game.load.image(#{name.inspect}, #{asset_path(f).inspect})" }.join(';') %>;
      game.load.spritesheet('doomfaces', <%= asset_path('doomfaces.png').inspect %>, FACE_WIDTH, FACE_HEIGHT, 42);
      game.load.spritesheet('lost_soul_basic', <%= asset_path('lost_soul_basic.png').inspect %>, 104, 90, 8);
      game.load.spritesheet('rgb_glow', <%= asset_path('rgb_120.png').inspect %>, 40, 40, 3);
      game.load.image('hourglass', <%= asset_path('hourglass_small.png').inspect %>);
      game.load.image('player_blip', <%= asset_path('green_blip_19.png').inspect %>);
    },
    create: function(){
      background = game.add.tileSprite(0, 0, 800, 600, 'starfield');
      walls = game.add.group();
      walls.add(game.add.tileSprite(160,60,480,40,'slate_flooring_40x40'));
      walls.add(game.add.tileSprite(160,500,480,40,'slate_flooring_40x40'));
      walls.add(game.add.tileSprite(160,100,40,400,'slate_flooring_40x40'));
      walls.add(game.add.tileSprite(600,100,40,400,'slate_flooring_40x40'));
      floor = game.add.tileSprite(200,100,400,400,'2x2brown40x40');

      souls = game.add.group();
      waitingIcons = game.add.group();
      glows = game.add.group();
      popups = game.add.group();

      player = newWaitingDoom(first_move[0],first_move[1],player_uuid);

      player.blip = game.add.sprite(14.5,-5,'player_blip',false);
      player.blip.anchor.setTo(0.5);
      player.addChild(player.blip);

      var waitingMap = {}
      var markAsChoosing = function(uuid) {
        var pos = playerPosMap[uuid];
        if(!pos || waitingMap[uuid]) return;

        console.log("marking as choosing");

        var icon = waitingIcons.getFirstDead();
        var x = xPosToX(pos[0])-20;
        var y = yPosToY(pos[1])-20;

        if (icon) {
          icon.reset(x,y);
          icon.alpha = 1;
        } else {
          icon = waitingIcons.create(x,y,'hourglass');
        }

        game.add.tween(icon).to({y: y-10},500,Phaser.Easing.Default,true,0,Number.MAX_VALUE,true);
        waitingMap[uuid] = icon;
      }

      var markAsWaiting = function(uuid) {
        console.log("marking as waiting");
        var img = waitingMap[uuid];
        if(!img) return;
        console.log('killing');
        game.add.tween(img)
          .to({y: img.y-20, alpha: 0},200,Phaser.Easing.Default,true)
          .onComplete.add(function(){
            img.kill();
          });
        delete waitingMap[uuid];
      }

      faye.subscribe('/room_events/waiting', function(payload) {
        console.log('waiting: '+payload);
        var data = JSON.parse(payload);
        if (data.current_round == turnCount) {
          console.log('marking');
          markAsWaiting(data.player_uuid);
        }
      });

      var moveSprite = function(sprite,nPos) {
        var cPos = sprite.currentPos;
        if (nPos[0] < cPos[0]) {
          sprite.animations.stop();
          sprite.animations.frame = 6;
        }
        else if (nPos[0] > cPos[0]) {
          sprite.animations.stop();
          sprite.animations.frame = 7;
        }
        else {
          sprite.animations.play('waiting');
        }

        cPos[0] = nPos[0];
        cPos[1] = nPos[1];

        game.add.tween(sprite).to({
          x: xPosToX(cPos[0])-sprite.width/2,
          y: yPosToY(cPos[1])-sprite.height/2
        }, sliderContainer.animationDuration, Phaser.Easing.Cubic.InOut, true);
      }

      faye.subscribe('/room_events/advance', function(payload) {
        console.log('advance! '+payload);
        var data = JSON.parse(payload);

        //TODO: Abstract out
        var hRound = new Hyperagent.Resource();
        hRound._load(data.halRound);
        hRound.loaded = true;

        var hPlayer = $.grep(hRound.embedded.participants, function(participant,i) {
          return (participant.props.uuid == player_uuid);
        })[0];

        glows.callAllExists('fadeAndKill',true);
        mm = window.MoveMatrix();

        popups.destroy(true,true);

        var isMoves = false;
        if(hPlayer !== undefined) {
          hPlayer.links['dv:moves'].fetch().then(function (moves) {
            $.each(moves.embedded.moves,function(i,move) {
              var newMoves = {}
              newMoves[move.props.action] = move.url()
              mm.at(move.props.x,move.props.y).addMoves(newMoves);
              var glow = glows.getFirstDead();
              var x = xPosToX(move.props.x);
              var y = yPosToY(move.props.y);
              if(glow) {
                glow.reset(x,y);
              } else {
                glow = glows.create(x,y,'rgb_glow');
              }
              glow.alpha = 0;
              glow.anchor.set(0.5);
              var blink;
              if(move.props.action == 'attack') {
                glow.frame = 0;
                blink = game.add.tween(glow).to({alpha: 0.4},sliderContainer.blinkDelay*0.7,Phaser.Easing.Quadratic.InOut,true,0,Number.MAX_VALUE,true);
              } else {
                glow.frame = 1;
                blink = game.add.tween(glow).to({alpha: 0.4},sliderContainer.blinkDelay,Phaser.Easing.Quadratic.InOut,true,0,Number.MAX_VALUE,true);
              }

              glow.fadeAndKill = function() {
                blink.stop();
                game.add.tween(glow).to({alpha: 0.0},sliderContainer.blinkDelay*(glow.alpha/0.4),Phaser.Easing.Quadratic.InOut,true,0)
                  .onComplete.add(function() {
                    glow.kill();
                  });
              }

              isMoves = true;
              glow.inputEnabled = true;
              glow.events.onInputUp.add(function(g) {
                var offsets = [
                  [+30,+20],
                  [-30,+20],
                  [+30,-20],
                  [-30,-20],
                  [0,0]
                ]

                popups.destroy(true,true);

                $.each(mm.at(move.props.x,move.props.y).moves, function(name, url) {
                  var offset = offsets.pop();
                  var text = game.add.text(
                    x+offset[0],
                    y+offset[1],
                    name.toUpperCase(),
                    { font: "16px Arial", fill: "#ffffff", align: "center" }
                  );
                  popups.add(text);
                  text.anchor.set(0.5);
                  text.inputEnabled = true;
                  text.events.onInputUp.add(function(t) {
                    $.ajax(url, {
                      type: "POST",
                      statusCode: {
                        422: function (response) {
                          //TODO: move this up out of the POST
                          //game.add.tween(player).to({x: player.x-5},50,Phaser.Easing.Default,true,0,5,true);
                        },
                        500: function (response) {
                           location.reload();
                        },
                        403: function (response) {
                          //TODO: auth lol
                          //location.reload();
                        }
                      }
                    });
                  }, this);
                });
              });
            });
            //if(isMoves) debugger;
          });
        }

        $.each(waitingMap, function(uuid,_) {
          markAsWaiting(uuid);
        });

        var numOfPlayers = 0;
        for (k in data.players) {
          if (data.players.hasOwnProperty(k)) {
            numOfPlayers++;
          }
        }
        numOfPlayers-= data.killed.length;

        $.each(data.players, function(uuid,pos) {
          playerPosMap[uuid] = pos;
          console.log(data.players);
        });
        console.log('new pos map - '+JSON.stringify(playerPosMap))
        turnCount = data.current_round+1;

        $.each(playerPosMap, function(uuid, soulData) {
          var soul = souls.filter(function(s,i,group) {
              return s.alive && s.uuid == uuid
            }).first;
          if(soul){
            moveSprite(soul,soulData);
          } else {
            newWaitingDoom(soulData[0],soulData[1],uuid);
          }

          if(numOfPlayers > 1 && data.players.hasOwnProperty(uuid)) {
            markAsChoosing(uuid);
          }
        });

        $.each(souls.filter(function(s,i,group) {
          return $.inArray(s.uuid,data.killed) > -1
        }).list, function(i,soul) {
          soul.animations.stop();
          soul.frame = 40;
          markAsWaiting(soul.uuid);
          delete playerPosMap[soul.uuid];
          if(soul.uuid === player_uuid) {
            game.input.onUp.add(function(p){
              location.reload();
            },this);
          }
        });
      });
    },
    update: function(){
    }
  });
});
