//= require phaser

$(function() {
  var sliderContainer = {};
  var player_uuid = window._divided_player_uuid;
  var first_move = window._divided_first_move;

  $('.slider').slider({min: 50, max: 5000,
    change: function(event,ui){
      var varname = $(ui.handle.parentElement).data('variable');
      $('td#'+varname+'-display').html(ui.value);
      sliderContainer[varname] = ui.value;
    },
    create: function(event,ui){
      var target = $(event.target);
      sliderContainer[target.data('variable')] = target.data('default');
    }
  });

  var background, walls, floor, cursors;
  var xPosToX = function(xPos) {
    return xPos*40+20+200;
  }
  var yPosToY = function(yPos) {
    return xPosToX(yPos)-100;
  }
  var xToXPos = function(x) {
    return Math.round((x-20-200)/40);
  }
  var yToYPos = function(y) {
    return xToXPos(y+100);
  }
  var turnCount = 0;
  var playerPosMap = {};

  // var source = new EventSource('/turns?player_uuid='+player_uuid);
  // source.addEventListener('turns.new', function(e) {
  //   console.log(e.data);
  //   var data = JSON.parse(e.data)
  //   var new_round = parseInt(data.current_round);
  //   playerPosMap = data.players;

  //   if (new_round > turnCount) {
  //     turnCount = new_round;
  //     console.log('turn '+new_round);
  //     turnDue = true;
  //   } else {
  //     console.log('got dupe turn '+new_round);
  //   }
  // });
  var faye = new Faye.Client('/faye');

  var player;
  var currentPos = JSON.parse(first_move);
  console.log(currentPos);
  var souls;
  var isPointerDown = false;
  var waitingIcons;

  var FACE_WIDTH = 30;
  var FACE_HEIGHT = 32;

  var newWaitingDoom = function(xPos,yPos){
    var doom = game.add.sprite(
      xPosToX(xPos)-FACE_WIDTH/2, yPosToY(yPos)-FACE_HEIGHT/2, 'doomfaces'
    );

    doom.animations.add('waiting',[4,4,4,4,4,4,3,5],2,true);
    doom.animations.play('waiting');

    return doom;
  }

  var game = new Phaser.Game(800, 600, Phaser.AUTO, 'divided-viewport', {
    preload: function() {
      <%= %w(starfield.jpg slate_flooring_40x40.png 2x2brown40x40.png).map{|f| name=f.split('.').first; "game.load.image(#{name.inspect}, #{asset_path(f).inspect})" }.join(';') %>;
      game.load.spritesheet('doomfaces', <%= asset_path('doomfaces.png').inspect %>, FACE_WIDTH, FACE_HEIGHT, 42);
      game.load.spritesheet('lost_soul_basic', <%= asset_path('lost_soul_basic.png').inspect %>, 104, 90, 8);
      game.load.image('hourglass', <%= asset_path('hourglass_small.png').inspect %>);
      game.load.image('player_blip', <%= asset_path('green_blip_19.png').inspect %>);
      game.load.image('orange_glow', <%= asset_path('orange_40x40.png').inspect %>);
      game.load.image('blue_glow', <%= asset_path('blue_40x40.png').inspect %>);
    },
    create: function(){
      background = game.add.tileSprite(0, 0, 800, 600, 'starfield');
      walls = game.add.group();
      walls.add(game.add.tileSprite(160,60,480,40,'slate_flooring_40x40'));
      walls.add(game.add.tileSprite(160,500,480,40,'slate_flooring_40x40'));
      walls.add(game.add.tileSprite(160,100,40,400,'slate_flooring_40x40'));
      walls.add(game.add.tileSprite(600,100,40,400,'slate_flooring_40x40'));
      floor = game.add.tileSprite(200,100,400,400,'2x2brown40x40');

      player = newWaitingDoom(currentPos[0],currentPos[1]);

      player.blip = game.add.sprite(14.5,-5,'player_blip',false);
      player.blip.anchor.setTo(0.5);
      player.addChild(player.blip);

      souls = game.add.group();

      waitingIcons = game.add.group();

      var waitingMap = {}
      var markAsChoosing = function(uuid) {
        var pos = playerPosMap[uuid];
        if(!pos || waitingMap[uuid]) return;

        console.log("marking as choosing");

        var icon = waitingIcons.getFirstDead();
        var x = xPosToX(pos[0])-20;
        var y = yPosToY(pos[1])-20;

        if (icon) {
          icon.reset(x,y);
          icon.alpha = 1;
        } else {
          icon = waitingIcons.create(x,y,'hourglass');
        }

        game.add.tween(icon).to({y: y-10},500,Phaser.Easing.Default,true,0,Number.MAX_VALUE,true);
        waitingMap[uuid] = icon;
      }

      var markAsWaiting = function(uuid) {
        console.log("marking as waiting");
        var img = waitingMap[uuid];
        if(!img) return;
        console.log('killing');
        game.add.tween(img)
          .to({y: img.y-20, alpha: 0},200,Phaser.Easing.Default,true)
          .onComplete.add(function(){
            img.kill();
          });
        delete waitingMap[uuid];
      }

      faye.subscribe('/room_events/waiting', function(payload) {
        console.log('waiting: '+payload);
        var data = JSON.parse(payload);
        if (data.current_round == turnCount) {
          console.log('marking');
          markAsWaiting(data.player_uuid);
        }
      });

      var moveSprite = function(sprite,cPos,nPos) {
        cPos[0] = nPos[0];
        cPos[1] = nPos[1];

        game.add.tween(sprite).to({
          x: xPosToX(cPos[0])-sprite.width/2,
          y: yPosToY(cPos[1])-sprite.height/2
        }, sliderContainer.animationDuration, Phaser.Easing.Cubic.InOut, true);
      }

      var isClose = function(soulPos){
        return Math.abs(soulPos[0]-currentPos[0]) <= 1 && Math.abs(soulPos[1]-currentPos[1]) <= 1;
      }

      faye.subscribe('/room_events/advance', function(payload) {
        console.log('advance! '+payload);
        var data = JSON.parse(payload);

        //TODO: check round


        $.each(waitingMap, function(uuid,_){
          markAsWaiting(uuid);
        });

        var numOfPlayers = 0;
        for (k in data.players) if (data.players.hasOwnProperty(k)) numOfPlayers++;

        $.each(data.players, function(uuid,pos){
          playerPosMap[uuid] = pos;
          console.log(data.players);
          if (numOfPlayers > 1) markAsChoosing(uuid);
        });
        console.log('new pos map - '+JSON.stringify(playerPosMap))
        turnCount = data.current_round+1;

        var playerPos = playerPosMap[player_uuid] || currentPos;

        if (playerPos[0] < currentPos[0]) {
          player.animations.stop();
          player.animations.frame = 6;
        }
        else if (playerPos[0] > currentPos[0]) {
          player.animations.stop();
          player.animations.frame = 7;
        }
        else {
          player.animations.play('waiting');
        }

        moveSprite(player,currentPos,playerPos);

        $.each(playerPosMap, function(uuid, soulData){
          if(uuid == player_uuid) return;

          var soul = souls.filter(function(s,i,group){return s.uuid == uuid}).first;
          if(soul){
            moveSprite(soul,soul.currentPos,soulData);
          } else {
            soul = newWaitingDoom(soulData[0],soulData[1]);
            souls.add(soul);
            soul.currentPos = soulData;
            soul.uuid = uuid;
          }

          soul.animations.stop();
          if(isClose(soul.currentPos)) {
            soul.animations.frame = 40;
          } else {
            soul.animations.play('waiting');
          }
        });
      });
    },
    update: function(){
      if (!isPointerDown && game.input.activePointer.isDown) {
        isPointerDown = true;
      } else if (isPointerDown && game.input.activePointer.isUp) {
        isPointerDown = false;
        var nextPos = [];
        nextPos[0] = xToXPos(game.input.activePointer.x);
        nextPos[1] = yToYPos(game.input.activePointer.y);

        for(var i = 0; i < 2; i++) {
          if(nextPos[i] < 0) nextPos[i] = 0;
          if(nextPos[i] > 9) nextPos[i] = 9;
        }

        console.log('post!');

        $.ajax('/turns', {
          type: "POST",
          data: {
            current_round: turnCount,
            player_uuid: player_uuid,
            next_pos: nextPos
          },
          statusCode: {
            422: function (response) {
               game.add.tween(player).to({x: player.x-5},50,Phaser.Easing.Default,true,0,5,true);
            },
            500: function (response) {
               location.reload();
            }
          }
        });
      }
    }
  });
});
